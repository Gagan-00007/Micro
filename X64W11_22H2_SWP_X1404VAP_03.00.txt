EX-1

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Day {
    char *dayName;
    int date;
    char *activity;
};
void create(struct Day *day) {
    day->dayName = (char *)malloc(sizeof(char) * 20);
    day->activity = (char *)malloc(sizeof(char) * 100);

    printf("Enter the day name: ");
    scanf("%s", day->dayName);
    
    printf("Enter the date: ");
    scanf("%d", &day->date);
    
    printf("Enter the activity for the day: ");
    // Read string with spaces until newline
    scanf(" %[^\n]s", day->activity); 
}
void read(struct Day *calendar, int size) {
    for (int i = 0; i < size; i++) {
        printf("Enter details for Day %d\n", i + 1);
        create(&calendar[i]);
    }
}
void display(struct Day *calendar, int size) {
    printf("\nWeek's Activity Details:\n");
    for (int i = 0; i < size; i++) {
        printf("Day %d:\n", i + 1);
        printf("Day Name: %s\n", calendar[i].dayName);
        printf("Date: %d\n", calendar[i].date);
        printf("Activity: %s\n", calendar[i].activity);
        printf("\n");
    }
}
void freeMemory(struct Day *calendar, int size) {
    for (int i = 0; i < size; i++) {
        free(calendar[i].dayName);
        free(calendar[i].activity);
    }
}
int main() {
    int size;
    printf("Enter the number of days in the week: ");
    scanf("%d", &size);
   struct Day *calendar = (struct Day *)malloc(sizeof(struct Day) * size);
    if (calendar == NULL) {
        printf("Memory allocation failed. Exiting program.\n");
        return 1;
    }
    read(calendar, size);
    display(calendar, size);
    freeMemory(calendar, size);
    free(calendar);
    return 0;
}

EX-2

#include <stdio.h>
#include <string.h> 
char str[100], pat[50], rep[50], res[100];
int i = 0, j = 0, c = 0, m = 0, k, flag = 0;
void stringmatch() {
    while (str[c] != '\0') {
        if (str[m] == pat[i]) {
            i++;
            m++;
            if (pat[i] == '\0') {
                flag = 1;
                for (k = 0; rep[k] != '\0'; k++, j++) {
                    res[j] = rep[k];
                }
                i = 0;
                c = m;
            }
        } else {
            res[j] = str[c];
            j++;
            c++;
            m = c;
            i = 0;
        }
    }
    res[j] = '\0';
}
void main() {
    printf("Enter the main string: ");
    gets(str);
    printf("\nEnter the pat string: ");
    gets(pat);
    printf("\nEnter the replace string: ");
    gets(rep);   
    printf("\nThe string before pattern match is:\n %s", str);
    stringmatch();
    if (flag == 1)
        printf("\nThe string after pattern match and replace is: \n %s", res);
    else
        printf("\nPattern string is not found");
}

EX-3

#include <stdio.h>
#include <stdlib.h>

#define MAX 3
int s[MAX];
int top = -1;

void push(int item);
int pop();
void palindrome();
void display();

void main() {
    int choice, item;
    while (1) {
        printf("\n\nMenu: ");
        printf("\n1. Push an Element to Stack and Overflow demo");
        printf("\n2. Pop an Element from Stack and Underflow demo");
        printf("\n3. Palindrome demo");
        printf("\n4. Display");
        printf("\n5. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &choice);
        
        switch (choice) {
            case 1:
                printf("\nEnter an element to be pushed: ");
                scanf("%d", &item);
                push(item);
                break;
            case 2:
                item = pop();
                if (item != -1)
                    printf("\nElement popped is: %d", item);
                break;
            case 3:
                palindrome();
                break;
            case 4:
                display();
                break;
            case 5:
                exit(0);
            default:
                printf("\nPlease enter valid choice");
                break;
        }
    }
}

void push(int item) {
    if (top == MAX - 1) {
        printf("\nStack overflow");
        return;
    }
    top = top + 1;
    s[top] = item;
}

int pop() {
    int item;
    if (top == -1) {
        printf("\nStack underflow");
        return -1;
    }
    item = s[top];
    top = top - 1;
    return item;
}

void display() {
    int i;
    if (top == -1) {
        printf("\nStack is empty");
        return;
    }
    printf("\nStack elements are:\n");
    for (i = top; i >= 0; i--)
        printf("%d \n", s[i]);
}

void palindrome() {
    int flag = 1, i;
    printf("\nStack content are:\n");
    for (i = top; i >= 0; i--)
        printf("%d \n", s[i]);
    
    printf("\nReverse of stack content are:\n");
    for (i = 0; i <= top; i++)
        printf("%d \n", s[i]);
        
    for (i = 0; i <= top / 2; i++) {
        if (s[i] != s[top - i]) {
            flag = 0;
            break;
        }
    }
    if (flag == 1)
        printf("\nIt is palindrome number");
    else
        printf("\nIt is not a palindrome number");
}

EX-4

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h> // For isalnum check if needed, though manual logic handles it in default

void evaluate();
void push(char);
char pop();
int prec(char);

char infix[30], postfix[30], stack[30];
int top = -1;

void main() {
    printf("\nEnter the valid infix expression: ");
    scanf("%s", infix);
    evaluate();
    printf("\nThe entered infix expression is: \n %s \n", infix);
    printf("\nThe corresponding postfix expression is: \n %s \n", postfix);
}

void evaluate() {
    int i = 0, j = 0;
    char symb, temp;
    push('#');
    
    for (i = 0; infix[i] != '\0'; i++) {
        symb = infix[i];
        switch (symb) {
            case '(':
                push(symb);
                break;
            case ')':
                temp = pop();
                while (temp != '(') {
                    postfix[j] = temp;
                    j++;
                    temp = pop();
                }
                break;
            case '+':
            case '-':
            case '*':
            case '/':
            case '%':
            case '^':
            case '$':
                while (prec(stack[top]) >= prec(symb)) {
                    temp = pop();
                    postfix[j] = temp;
                    j++;
                }
                push(symb);
                break;
            default:
                postfix[j] = symb;
                j++;
        }
    }
    while (top > 0) {
        temp = pop();
        postfix[j] = temp;
        j++;
    }
    postfix[j] = '\0';
}

void push(char item) {
    top = top + 1;
    stack[top] = item;
}

char pop() {
    char item;
    item = stack[top];
    top = top - 1;
    return item;
}

int prec(char symb) {
    int p;
    switch (symb) {
        case '#':
            p = -1;
            break;
        case '(':
        case ')':
            p = 0;
            break;
        case '+':
        case '-':
            p = 1;
            break;
        case '*':
        case '/':
        case '%':
            p = 2;
            break;
        case '^':
        case '$':
            p = 3;
            break;
    }
    return p;
}

EX-5

#include <stdio.h>
#include <math.h>

void tower(int n, int source, int temp, int destination) {
    if (n == 0)
        return;
    tower(n - 1, source, destination, temp);
    printf("\nMove disc %d from %c to %c", n, source, destination);
    tower(n - 1, temp, source, destination);
}

void main() {
    int n;
    printf("\nEnter the number of discs: \n");
    scanf("%d", &n);
    tower(n, 'A', 'B', 'C');
    printf("\n\nTotal Number of moves are: %d", (int)pow(2, n) - 1);
}

EX-6

#include <stdio.h>
#include <stdlib.h>

#define MAX 5
char circular_queue[MAX];
int front = -1, rear = -1;

int isEmpty() {
    if (front == -1 && rear == -1)
        return 1;
    else
        return 0;
}

int isfull() {
    if ((rear + 1) % MAX == front)
        return 1;
    else
        return 0;
}

void insertElement(char element) {
    if (isfull()) {
        printf("Circular Queue Overflow\n");
        return;
    } else if (isEmpty()) {
        front = rear = 0;
    } else {
        rear = (rear + 1) % MAX;
    }
    circular_queue[rear] = element;
}

void deleteElement() {
    if (isEmpty()) {
        printf("Circular Queue Underflow\n");
        return;
    } else if (front == rear) {
        front = rear = -1;
    } else {
        front = (front + 1) % MAX;
    }
}

void display() {
    int i;
    if (isEmpty()) {
        printf("Circular Queue is empty \n");
        return;
    }
    printf("Circular Queue elements: ");
    i = front;
    do {
        printf("%c", circular_queue[i]);
        i = (i + 1) % MAX;
    } while (i != (rear + 1) % MAX);
    printf("\n");
}

int main() {
    int choice;
    char element;
    do {
        printf("\n\n---- Circular Queue Menu ----\n");
        printf("1. Insert an Element\n");
        printf("2. Delete an Element\n");
        printf("3. Display Circular Queue\n");
        printf("4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        
        switch (choice) {
            case 1:
                printf("Enter element to be inserted: ");
                scanf(" %c", &element);
                insertElement(element);
                break;
            case 2:
                deleteElement();
                break;
            case 3:
                display();
                break;
            case 4:
                printf("Exiting...\n");
                break;
            default:
                printf("Invalid choice! Please enter a valid option.\n");
        }
    } while (choice != 4);
    return 0;
}

EX-7

#include <stdio.h>
#include <stdlib.h>

struct node {
    char usn[25], name[25], branch[25];
    int sem;
    long int phone;
    struct node *link;
};
typedef struct node *NODE;

NODE start = NULL;
int count = 0;

NODE create() {
    NODE snode;
    snode = (NODE)malloc(sizeof(struct node));
    if (snode == NULL) {
        printf("\nMemory is not available");
        exit(1);
    }
    printf("\nEnter the usn, Name, Branch, sem, Phone No of the student: ");
    scanf("%s %s %s %d %ld", snode->usn, snode->name, snode->branch, &snode->sem, &snode->phone);
    snode->link = NULL;
    count++;
    return snode;
}

NODE insertfront() {
    NODE temp;
    temp = create();
    if (start == NULL) {
        return temp;
    }
    temp->link = start;
    return temp;
}

NODE deletefront() {
    NODE temp;
    if (start == NULL) {
        printf("\nLinked list is empty");
        return NULL;
    }
    if (start->link == NULL) {
        printf("\nThe Student node with usn: %s is deleted", start->usn);
        count--;
        free(start);
        return NULL;
    }
    temp = start;
    start = start->link;
    printf("\nThe Student node with usn: %s is deleted", temp->usn);
    count--;
    free(temp);
    return start;
}

NODE insertend() {
    NODE cur, temp;
    temp = create();
    if (start == NULL) {
        return temp;
    }
    cur = start;
    while (cur->link != NULL) {
        cur = cur->link;
    }
    cur->link = temp;
    return start;
}

NODE deleteend() {
    NODE cur, prev;
    if (start == NULL) {
        printf("\nLinked List is empty");
        return NULL;
    }
    if (start->link == NULL) {
        printf("\nThe student node with the usn: %s is deleted", start->usn);
        free(start);
        count--;
        return NULL;
    }
    prev = NULL;
    cur = start;
    while (cur->link != NULL) {
        prev = cur;
        cur = cur->link;
    }
    printf("\nThe student node with the usn: %s is deleted", cur->usn);
    free(cur);
    prev->link = NULL;
    count--;
    return start;
}

void display() {
    NODE cur;
    int num = 1;
    if (start == NULL) {
        printf("\nNo Contents to display in SLL \n");
        return;
    }
    printf("\nThe contents of SLL: \n");
    cur = start;
    while (cur != NULL) {
        printf("\n %d | USN:%s | Name:%s | Branch:%s | Sem:%d | Ph:%ld |", num, cur->usn, cur->name, cur->branch, cur->sem, cur->phone);
        cur = cur->link;
        num++;
    }
    printf("\n No of student nodes is %d \n", count);
}

void stackdemo() {
    int ch;
    while (1) {
        printf("\nStack Demo using SLL\n");
        printf("\n1: Push operation \n2: Pop operation \n3: Display \n4: Exit \n");
        printf("\nEnter your choice for stack demo: ");
        scanf("%d", &ch);
        switch (ch) {
            case 1: start = insertfront(); break;
            case 2: start = deletefront(); break;
            case 3: display(); break;
            default: return;
        }
    }
}

int main() {
    int ch, i, n;
    while (1) {
        printf("\n---Menu---");
        printf("\nEnter your choice for SLL operation \n");
        printf("\n1: Create SLL of Student Nodes");
        printf("\n2: Display Status");
        printf("\n3: InsertAtEnd");
        printf("\n4: DeleteAtEnd");
        printf("\n5: Stack Demo using SLL (Insertion and Deletion at Front)");
        printf("\n6: Exit \n");
        printf("\nEnter your choice: ");
        scanf("%d", &ch);
        
        switch (ch) {
            case 1:
                printf("\nEnter the no of students: ");
                scanf("%d", &n);
                for (i = 1; i <= n; i++)
                    start = insertfront();
                break;
            case 2: display(); break;
            case 3: start = insertend(); break;
            case 4: start = deleteend(); break;
            case 5: stackdemo(); break;
            case 6: exit(0);
            default: printf("\nPlease enter the valid choice");
        }
    }
}

EX-8

#include <stdio.h>
#include <stdlib.h>

struct node {
    char ssn[25], name[25], dept[10], designation[25];
    int sal;
    long int phone;
    struct node *llink;
    struct node *rlink;
};
typedef struct node *NODE;

NODE first = NULL;
int count = 0;

NODE create() {
    NODE enode;
    enode = (NODE)malloc(sizeof(struct node));
    if (enode == NULL) {
        printf("\nRunning out of memory");
        exit(0);
    }
    printf("\nEnter the ssn, Name, Department, Designation, Salary, Phone No of the employee: \n");
    scanf("%s %s %s %s %d %ld", enode->ssn, enode->name, enode->dept, enode->designation, &enode->sal, &enode->phone);
    enode->llink = NULL;
    enode->rlink = NULL;
    count++;
    return enode;
}

NODE insertfront() {
    NODE temp;
    temp = create();
    if (first == NULL) {
        return temp;
    }
    temp->rlink = first;
    first->llink = temp;
    return temp;
}

void display() {
    NODE cur;
    int nodeno = 1;
    cur = first;
    if (cur == NULL)
        printf("\nNo Contents to display in DLL");
    while (cur != NULL) {
        printf("\nNode:%d | SSN:%s | Name:%s | Department:%s | Designation:%s | Salary:%d | Phone no:%ld |", nodeno, cur->ssn, cur->name, cur->dept, cur->designation, cur->sal, cur->phone);
        cur = cur->rlink;
        nodeno++;
    }
    printf("\nNo of employee nodes is %d", count);
}

NODE deletefront() {
    NODE temp;
    if (first == NULL) {
        printf("\nDoubly Linked List is empty");
        return NULL;
    }
    if (first->rlink == NULL) {
        printf("\nThe employee node with the ssn: %s is deleted", first->ssn);
        free(first);
        count--;
        return NULL;
    }
    temp = first;
    first = first->rlink;
    first->llink = NULL;
    printf("\nThe employee node with the ssn: %s is deleted", temp->ssn);
    free(temp);
    count--;
    return first;
}

NODE insertend() {
    NODE cur, temp;
    temp = create();
    if (first == NULL) {
        return temp;
    }
    cur = first;
    while (cur->rlink != NULL) {
        cur = cur->rlink;
    }
    cur->rlink = temp;
    temp->llink = cur;
    return first;
}

NODE deleteend() {
    NODE cur;
    if (first == NULL) {
        printf("\nDoubly Linked List is empty");
        return NULL;
    }
    if (first->rlink == NULL) {
        printf("\nThe employee node with the ssn: %s is deleted", first->ssn);
        free(first);
        count--;
        return NULL;
    }
    cur = first;
    while (cur->rlink != NULL) {
        cur = cur->rlink;
    }
    cur->llink->rlink = NULL;
    printf("\nThe employee node with the ssn: %s is deleted", cur->ssn);
    free(cur);
    count--;
    return first;
}

void deqdemo() {
    int ch;
    while (1) {
        printf("\nDemo Double Ended Queue Operation");
        printf("\n1: InsertQueueFront \n2: DeleteQueueFront \n3: InsertQueueRear \n4: DeleteQueueRear \n5: Display Status \n6: Exit \n");
        scanf("%d", &ch);
        switch (ch) {
            case 1: first = insertfront(); break;
            case 2: first = deletefront(); break;
            case 3: first = insertend(); break;
            case 4: first = deleteend(); break;
            case 5: display(); break;
            default: return;
        }
    }
}

void main() {
    int ch, i, n;
    while (1) {
        printf("\n\n--Menu----");
        printf("\n1: Create DLL of Employee Nodes");
        printf("\n2: Display Status");
        printf("\n3: InsertAtEnd");
        printf("\n4: DeleteAtEnd");
        printf("\n5: InsertAtFront");
        printf("\n6: DeleteAtFront");
        printf("\n7: Double Ended Queue Demo using DLL");
        printf("\n8: Exit \n");
        printf("\nPlease enter your choice: ");
        scanf("%d", &ch);
        
        switch (ch) {
            case 1:
                printf("\nEnter the no of Employees: ");
                scanf("%d", &n);
                for (i = 1; i <= n; i++)
                    first = insertend();
                break;
            case 2: display(); break;
            case 3: first = insertend(); break;
            case 4: first = deleteend(); break;
            case 5: first = insertfront(); break;
            case 6: first = deletefront(); break;
            case 7: deqdemo(); break;
            case 8: exit(0);
            default: printf("\nPlease Enter the valid choice");
        }
    }
}

EX-9

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
struct Term {
int coeff;
int x_exponent;
int y_exponent;
int z_exponent;
struct Term* next;
};
struct Term* createTerm(int coeff, int x_exp, int y_exp, int z_exp) {
struct Term* newTerm = (struct Term*)malloc(sizeof(struct Term));
newTerm->coeff = coeff;
newTerm->x_exponent = x_exp;
newTerm->y_exponent = y_exp;
newTerm->z_exponent = z_exp;
newTerm->next = NULL;
return newTerm;
}
void insertTerm(struct Term** head, int coeff, int x_exp, int y_exp, int z_exp) {
struct Term* newTerm = createTerm(coeff, x_exp, y_exp, z_exp);
if (*head == NULL) {
*head = newTerm;
newTerm->next = *head;
} else {
struct Term* current = *head;
while (current->next != *head) {
current = current->next;
}
current->next = newTerm;
newTerm->next = *head;
}
}
void displayPolynomial(struct Term* head) {
if (!head) {
printf("Polynomial is empty.\n");
return;
}
struct Term* current = head;
do {
printf("%dx^%dy^%dz^%d", current->coeff, current->x_exponent, current-
>y_exponent, current->z_exponent);
current = current->next;
if (current != head) {
printf(" + ");
}
} while (current != head);
printf("\n");
}
struct Term* addPolynomials(struct Term* poly1, struct Term* poly2) {
struct Term* resultPoly = NULL;
struct Term* current1 = poly1;
struct Term* current2 = poly2;
do {
int sumCoeff = current1->coeff + current2->coeff;
insertTerm(&resultPoly, sumCoeff, current1->x_exponent, current1->y_exponent,
current1->z_exponent);
current1 = current1->next;
current2 = current2->next;
} while (current1 != poly1 && current2 != poly2);
return resultPoly;
}
void freeList(struct Term** head) {
if (*head == NULL) {
return;
}
struct Term* current = *head;
struct Term* next;
do {
next = current->next;
free(current);
current = next;
} while (current != *head);
*head = NULL;
}
int main() {
struct Term* poly1 = NULL;
struct Term* poly2 = NULL;
insertTerm(&poly1, 6, 2, 2, 1);
insertTerm(&poly1, -4, 0, 1, 5);
insertTerm(&poly1, 3, 3, 1, 1);
insertTerm(&poly1, 2, 1, 5, 1);
insertTerm(&poly1, -2, 1, 1, 3);
displayPolynomial(poly1);
insertTerm(&poly2, 2, 2, 2, 1);
insertTerm(&poly2, 5, 0, 1, 5);
insertTerm(&poly2, -1, 3, 1, 1);
displayPolynomial(poly2);
struct Term* polySum = addPolynomials(poly1, poly2);
displayPolynomial(polySum);
freeList(&poly1);
freeList(&poly2);
freeList(&polySum);
return 0;
}

EX-10

#include <stdio.h>
#include <stdlib.h>

struct BST {
    int data;
    struct BST *lchild;
    struct BST *rchild;
};
typedef struct BST *NODE;

NODE create() {
    NODE temp;
    temp = (NODE)malloc(sizeof(struct BST));
    printf("\nEnter The value: ");
    scanf("%d", &temp->data);
    temp->lchild = NULL;
    temp->rchild = NULL;
    return temp;
}

void insert(NODE root, NODE newnode);
void inorder(NODE root);
void preorder(NODE root);
void postorder(NODE root);
void search(NODE root);

void insert(NODE root, NODE newnode) {
    if (newnode->data < root->data) {
        if (root->lchild == NULL)
            root->lchild = newnode;
        else
            insert(root->lchild, newnode);
    }
    if (newnode->data > root->data) {
        if (root->rchild == NULL)
            root->rchild = newnode;
        else
            insert(root->rchild, newnode);
    }
}

void search(NODE root) {
    int key;
    NODE cur;
    if (root == NULL) {
        printf("\nBST is empty.");
        return;
    }
    printf("\nEnter Element to be searched: ");
    scanf("%d", &key);
    cur = root;
    while (cur != NULL) {
        if (cur->data == key) {
            printf("\nKey element is present in BST");
            return;
        }
        if (key < cur->data)
            cur = cur->lchild;
        else
            cur = cur->rchild;
    }
    printf("\nKey element is not found in the BST");
}

void inorder(NODE root) {
    if (root != NULL) {
        inorder(root->lchild);
        printf("%d ", root->data);
        inorder(root->rchild);
    }
}

void preorder(NODE root) {
    if (root != NULL) {
        printf("%d ", root->data);
        preorder(root->lchild);
        preorder(root->rchild);
    }
}

void postorder(NODE root) {
    if (root != NULL) {
        postorder(root->lchild);
        postorder(root->rchild);
        printf("%d ", root->data);
    }
}

void main() {
    int ch, i, n;
    NODE root = NULL, newnode;
    while (1) {
        printf("\nBST MENU");
        printf("\n1. Create a BST");
        printf("\n2. Search");
        printf("\n3. BST Traversals");
        printf("\n4. Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &ch);
        switch (ch) {
            case 1:
                printf("\nEnter the number of elements: ");
                scanf("%d", &n);
                for (i = 1; i <= n; i++) {
                    newnode = create();
                    if (root == NULL)
                        root = newnode;
                    else
                        insert(root, newnode);
                }
                break;
            case 2:
                search(root);
                break;
            case 3:
                if (root == NULL)
                    printf("\nTree Is Not Created");
                else {
                    printf("\nThe Preorder display: ");
                    preorder(root);
                    printf("\nThe Inorder display: ");
                    inorder(root);
                    printf("\nThe Postorder display: ");
                    postorder(root);
                }
                break;
            case 4:
                exit(0);
        }
    }
}